<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" Metasys® Server API Modules serverkit Classes serverkit~MetasysServerApi Tutorials Examples Calls For Most Common Methods Source: index.js /* eslint-disable no-await-in-loop, no-console */ const request = require('request-promise-native'); /** * @description A light weight REST API client for the the Metasys Server. * * This is a simple client designed to make it easy to deal with * the many collections of data provided by the server. * * Features: * * * Provides async generators for each collection resource. * These hide all of the server paging from you. * Instead you can iterate over the generators using `for-await`. The library * will fetch additional pages as needed. (You can also use {@link first} and {@link filter}). * * @example &lt;caption&gt;Example usage of iterating over an async generator&lt;/caption&gt; * {@lang javascript} * const api = require('@jci/serverkit'); * * async main() { * await api.login('user', 'pass', 'host'); * * const alarms = api.alarms({ priorityRange: '0,120' }); * for await (const alarm in alarms) { * console.log(JSON.stringify(alarm, null, 2)); * } * } * main(); * * @todo Add automatic retries * @todo Add better error handling * @todo Add methods that return array rather than generators. For now use `toArray` * @todo Detect when a call fails to token expiration and refresh token * @module serverkit * @tutorial example-calls */ /** * Any method that is both a generator and asynchronous. These types are new * to ECMAScript in version 9 (2018). They are created by defining a function * using the keywords `async` and `function*` like in the following: * * ```javascript * async function* myGenerator() { * // implementation here. * } * ``` * Such method are allowed to use `yield` in their implementation which makes it * easier to deal with asynchronous results. And they can be used with `await` keyword * which makes it easier to consume async results. * * You can use the new `for-await` statement to iterate over these generators: * * ```javascript * for await (const item of myGenerator()) { * console.log(item); * } * ``` * * All of the methods in this library that are marked `async` and `generator` return * instances of `AsyncGenerator`. Every method marked with these keywords have similar * properties: * * * The asynchronously fetch pages from the Metasys Server * * They only fetch a new page after you have consumed all of the items from the * current page. * * They don't cache their results. Every time you call one of these methods it * will result in calls to the server. If you want to iterate thru a collection * multiple times then store the results in an array. * * At the time of writing many other utility functions for dealing with this type * did not exist. Some helper methods are implemented in this library. * * * {@link filter} - Filter the results of a generator. (**Note:** This filter happens on the * client side. * if you wish to reduce the amount of data returned by the server use query parameters * in your call to limit the results.) * * {@link first} - Find the first item in the collection that matches your criteria. * (**Note:** This happens * client side. It may still results in multiple calls to the server. Use appropriate * query parameters to limit the results that must be searched thru.) * * {@link map} - Apply a transform operation to every element in a generator. * @typedef {Object} AsyncGenerator */ /** * A function that takes one parameter and returns a boolean. * @typedef {function(*): boolean} Predicate */ /** * * @param {AsyncGenerator} generator */ async function toArray(generator) { const gen = (generator instanceof Promise) ? await generator : generator; const array = []; /* eslint-disable-next-line no-restricted-syntax */ for await (const element of gen) { array.push(element); } return array; } /** * Creates a generator that only yields the elements of the given `generator` for which the predicate * evaluates to true. * is true. * @param {AsyncGenerator} generator - The generator to iterate over. * @param {Predicate} predicate - The function called on each element. * @returns {AsyncGenerator} - A generator that yields only the matching elements from given * `generator`. * @async * @generator */ async function* filter(generator, predicate) { const gen = (generator instanceof Promise) ? await generator : generator; /* eslint-disable-next-line no-restricted-syntax */ for await (const item of gen) { if (predicate(item)) { yield item; } } } /** * Iterates over elements of the generator and returns the first element it finds for which the * `predicate` returns true. * @param {AsyncGenerator|Promise&lt;AsyncGenerator&gt;} generator - The generator to iterate over * @param {Predicate} predicate - The function called on each element. * @returns {*} - The first element in the `generator` for which the `predicate` returns `true`, if * such an element exists. Returns `undefined` otherwise. * @async */ async function first(generator, predicate) { const gen = (generator instanceof Promise) ? await generator : generator; return (await filter(gen, predicate).next()).value; } /** * Returns a new generator that will apply the given transform function to each element * in the specified generator. * @param {AsyncGenerator} generator - The generator to iterate over. * @param {function(*): *} transform - The transform function to apply to each element. * @async * @generator */ async function* map(generator, transform) { const gen = (generator instanceof Promise) ? await generator : generator; /* eslint-disable-next-line no-restricted-syntax */ for await (const item of gen) { yield transform(item); } } /** * * * @class */ class MetasysServerApi { constructor(requestObject) { this.requestOriginal = requestObject || request; } /** * Logs the specified user into the Metasys Server and establishes a session. While this session * is active this instance can be used to make additional calls to the server. * * @param {String} user - The user name of the account being used to access Metasys Server * @param {*} pass - The password of the account being used to access Metasys Server. * @param {*} host - The hostname (or IP address) of the Metasys Server * @param {Object} [options] - Any options that you want to apply to every call as documented * by `request` library. */ async login(user, pass, host, options) { this.host = host; const url = `https://${host}/api/api/authentication/login`; const payload = { username: user, password: pass }; try { const result = await this.requestOriginal .post(Object.assign({ url, json: true, form: payload }, options)); this.options = Object.assign({ baseUrl: `https://${host}/api/v1`, json: true, auth: { bearer: result.access_token, }, }, options); this.rp = this.requestOriginal.defaults(this.options); } catch (e) { // check for some common issues: // 1. Proxy server used for local server // 2. Unknown host // 3. Bad credentials if (e.cause &amp;&amp; e.cause.code === 'ECONNRESET' &amp;&amp; e.message &amp;&amp; e.message.startsWith('Error: tunneling')) { console.log('Error: There was an issue establishing a connection to the server.'); console.log('This error is consistent with a proxy server being configured when accessing a local server,'); } else if (e.cause &amp;&amp; e.cause.code === 'ENOTFOUND') { console.log(`Error: Unknown server '${host}'.`); } else if (e.error &amp;&amp; e.error.ApiErrorMessage &amp;&amp; e.error.ApiErrorMessage.startsWith('Unable to login.') &amp;&amp; e.statusCode &amp;&amp; e.statusCode &gt;= 400 &amp;&amp; e.statusCode &lt; 500) { console.log('Error: There was an issue logging in. Your credentials may have been incorrect. Please try again.'); } else { console.log(e); } return false; } return true; } /** * A generator that lazily yields elements from the specified collection resource on * the server. * * This is a lazy function. It makes no call to the server until the first element * in the generator is requested by either calling `next()` or by using the `for await` * statement. It then only makes further calls to the server for additional pages when * needed. * @async * @generator * @param {String} collectionRelativeUrl * @param {Object.&lt;string,*&gt;} qs - An object that contains the query string parameters to include * on the request. * @private */ async* generator(collectionRelativeUrl, qs) { let url = collectionRelativeUrl; try { while (url) { const { items, next } = await this.get(url, qs); url = next; yield* items; } } catch (e) { // Metasys API often returns 404 for empty collections // Convert these to empty collections rather than an error if (e.statusCode === 404) { yield* []; } else { throw e; } } } async devices(queryString) { return this.generator('/networkDevices', Object.assign({ pageSize: 1000 }, queryString)); } async* supervisoryDevices() { const engineClassIds = [872, 871, 873, 877, 448, 613, 751, 192, 185, 610, 651, 193, 358, 611, 769, 425, 753, 752]; for (let i = 0; i &lt; engineClassIds.length; i += 1) { yield* await this.devices({ type: engineClassIds[i] }); } } async objects(options) { if (options.deviceId) { return this.generator(`/networkDevices/${options.deviceId}/objects`); } if (options.objectId) { return this.generator(`objects/${options.objectId}/objects`); } throw new Error('Must pass an object with either &quot;deviceId&quot; or &quot;objectId&quot; specified in calls to &quot;objects&quot; method.'); } /** * A generator that yields alarms from the server. * @param {Object} [queryString] - The query string parameters. If not * specified then startTime is set to midnight of current day, and endTime is * set to current time. (Both times are local times.) * @async * @generator * @yields {Object} The next alarm in the collection */ async alarms(queryString) { const endTime = new Date(Date.now()); const startTime = new Date(endTime.getFullYear(), endTime.getMonth(), endTime.getDate()); const qs = Object.assign({ pageSize: 1000, startTime, endTime }, queryString); let url; if (queryString.deviceId) { url = `/networkDevices/${queryString.deviceId}/alarms`; } else if (queryString.objectId) { url = `objects/${queryString.objectId}/alarms`; } else { url = '/alarms'; } return this.generator(url, qs); } async alarm(id) { return this.get(`/alarms/${id}`); } async audits(qs) { return this.generator('/audits', qs); } async equipment(qs) { return this.generator('/equipment', qs); } async spaces(qs) { return this.generator('/spaces', qs); } async trendedAttributes(objectId, qs) { return this.generator(`/objects/${objectId}/attributes`, qs); } async samples(objectId, attributeId, qs) { return this.generator(`/objects/${objectId}/attributes/${attributeId}`, qs); } assertLoggedIn() { if (!this.options || !this.options.auth || !this.options.auth.bearer) { throw new Error('Must successfully login first'); } } /** * Retrieves the specified resource. This is a helper method and is not meant to be called * directly. Use one of the more specific methods on this class instead. * * @param {String} relativeUrl - A relative URL to the resource desired. * @param {Object} [qs] - An optional object that defines any query string parameters. For example * the object `{ startTime:'2018-08-01', endTime:'2018-08-02' }` would set the query string * parameters for `startTime` and `endTime`. * @returns {*} - Returns the JSON response as an appropriate javascript type. * @async */ async get(relativeUrl, qs) { this.assertLoggedIn(); const options = Object.assign({ url: relativeUrl }, { qs }); return this.rp.get(options); } } class Reference { constructor(referenceString) { this.reference = referenceString; if (referenceString) { const parts = referenceString.split(':'); [this.siteName] = parts; if (parts[1]) { const deviceParts = parts[1].split('/'); [this.deviceName, this.path] = deviceParts; if (this.path) { this.pathParts = this.path.split('.'); } else { this.pathParts = []; } } } if (!this.siteName || !this.deviceName || !this.pathParts) { throw new Error(`Invalid reference string: ${referenceString}`); } } get engineReference() { if (this.siteName &amp;&amp; this.deviceName) { return `${this.siteName}:${this.deviceName}`; } return undefined; } get isEngineReference() { return this.pathParts.length === 0; } get referenceString() { return this.reference; } } module.exports = { MetasysServerApi, first, filter, map, toArray, Reference, }; × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Metasys® Server API Modules serverkit Classes serverkit~MetasysServerApi Tutorials Examples Calls For Most Common Methods Modules Classes MetasysServerApi × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Metasys® Server API Modules serverkit Classes serverkit~MetasysServerApi Tutorials Examples Calls For Most Common Methods Classes Classes MetasysServerApi × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Metasys® Server API Modules serverkit Classes serverkit~MetasysServerApi Tutorials Examples Calls For Most Common Methods Tutorials Classes MetasysServerApi × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Metasys® Server API Modules serverkit Classes serverkit~MetasysServerApi Tutorials Examples Calls For Most Common Methods @metasys/nodekit 1.0.2 nodekitMetasys® Server REST API client for node.js This library is used to consume the Metasys Server API. It currently supports V1 of the Metasys® Server API. Installationnpm install @metasys/nodekitUsageThe following example will log into the server, and fetch and print each alarm with a priority in the range of 0 to 10. const { MetasysServerApi } = require('@metasys/nodekit'); async function main() { const api = new MetasysServerApi(); await api.login('user', 'pass', 'host'); const alarms = await api.alarms({ priorityRange: '0,10' }); for await (const alarm of alarms) { console.log(JSON.stringify(alarm, null, 2)); } } main();Client OptionsThis library depends on request. You can pass an options argument as defined by request as the fourth parameter of the login method for any special options you need. These will be used on every future call made by the api. For example, if you are using a self signed certificate on your Metasys Server, then the calls to the API may fail with certificate errors if your machine is not setup to trust the self-signed certificate. The easiest way to handle this is to get the cert in a .pem format and then specify that certificate in your login method: const fs = require('fs') const ca = fs.readFileSync('./path/to/cert.pem'); const api = require('@jci/serverkit'); async main() { await api.login('user', 'pass', 'host', { ca }); } main()See request for more options. × Search results Close "},"module-serverkit.html":{"id":"module-serverkit.html","title":"Module: serverkit","body":" Metasys® Server API Modules serverkit Classes serverkit~MetasysServerApi Tutorials Examples Calls For Most Common Methods Module: serverkit A light weight REST API client for the the Metasys Server. This is a simple client designed to make it easy to deal with the many collections of data provided by the server. Features: Provides async generators for each collection resource. These hide all of the server paging from you. Instead you can iterate over the generators using for-await. The library will fetch additional pages as needed. (You can also use first and filter). Source: index.js, line 4 Tutorials: Examples Calls For Most Common Methods To Do: Add automatic retries Add better error handling Add methods that return array rather than generators. For now use `toArray` Detect when a call fails to token expiration and refresh token Example Example usage of iterating over an async generator const api = require('@jci/serverkit'); async main() { await api.login('user', 'pass', 'host'); const alarms = api.alarms({ priorityRange: '0,120' }); for await (const alarm in alarms) { console.log(JSON.stringify(alarm, null, 2)); } } main(); Classes MetasysServerApi Methods &lt;async, generator, inner&gt; filter(generator, predicate) Creates a generator that only yields the elements of the given generator for which the predicate evaluates to true. is true. Parameters: Name Type Description generator AsyncGenerator The generator to iterate over. predicate Predicate The function called on each element. Source: index.js, line 117 Returns: A generator that yields only the matching elements from given generator. Type AsyncGenerator &lt;async, inner&gt; first(generator, predicate) Iterates over elements of the generator and returns the first element it finds for which the predicate returns true. Parameters: Name Type Description generator AsyncGenerator | Promise.&lt;AsyncGenerator&gt; The generator to iterate over predicate Predicate The function called on each element. Source: index.js, line 136 Returns: The first element in the generator for which the predicate returns true, if such an element exists. Returns undefined otherwise. Type * &lt;async, generator, inner&gt; map(generator, transform) Returns a new generator that will apply the given transform function to each element in the specified generator. Parameters: Name Type Description generator AsyncGenerator The generator to iterate over. transform function The transform function to apply to each element. Source: index.js, line 149 &lt;async, inner&gt; toArray(generator) Parameters: Name Type Description generator AsyncGenerator Source: index.js, line 96 Type Definitions AsyncGenerator Any method that is both a generator and asynchronous. These types are new to ECMAScript in version 9 (2018). They are created by defining a function using the keywords async and function* like in the following: async function* myGenerator() { // implementation here. }Such method are allowed to use yield in their implementation which makes it easier to deal with asynchronous results. And they can be used with await keyword which makes it easier to consume async results. You can use the new for-await statement to iterate over these generators: for await (const item of myGenerator()) { console.log(item); }All of the methods in this library that are marked async and generator return instances of AsyncGenerator. Every method marked with these keywords have similar properties: The asynchronously fetch pages from the Metasys Server They only fetch a new page after you have consumed all of the items from the current page. They don't cache their results. Every time you call one of these methods it will result in calls to the server. If you want to iterate thru a collection multiple times then store the results in an array. At the time of writing many other utility functions for dealing with this type did not exist. Some helper methods are implemented in this library. filter - Filter the results of a generator. (Note: This filter happens on the client side. if you wish to reduce the amount of data returned by the server use query parameters in your call to limit the results.) first - Find the first item in the collection that matches your criteria. (Note: This happens client side. It may still results in multiple calls to the server. Use appropriate query parameters to limit the results that must be searched thru.) map - Apply a transform operation to every element in a generator. Type: Object Source: index.js, line 39 Predicate() A function that takes one parameter and returns a boolean. Source: index.js, line 87 × Search results Close "},"module-serverkit-MetasysServerApi.html":{"id":"module-serverkit-MetasysServerApi.html","title":"Class: MetasysServerApi","body":" Metasys® Server API Modules serverkit Classes serverkit~MetasysServerApi Tutorials Examples Calls For Most Common Methods Class: MetasysServerApi serverkit~ MetasysServerApi new MetasysServerApi() Source: index.js, line 162 Methods &lt;async, generator&gt; alarms( [queryString]) A generator that yields alarms from the server. Parameters: Name Type Argument Description queryString Object &lt;optional&gt; The query string parameters. If not specified then startTime is set to midnight of current day, and endTime is set to current time. (Both times are local times.) Source: index.js, line 281 &lt;async&gt; get(relativeUrl [, qs]) Retrieves the specified resource. This is a helper method and is not meant to be called directly. Use one of the more specific methods on this class instead. Parameters: Name Type Argument Description relativeUrl String A relative URL to the resource desired. qs Object &lt;optional&gt; An optional object that defines any query string parameters. For example the object { startTime:'2018-08-01', endTime:'2018-08-02' } would set the query string parameters for startTime and endTime. Source: index.js, line 337 Returns: Returns the JSON response as an appropriate javascript type. Type * &lt;async&gt; login(user, pass, host [, options]) Logs the specified user into the Metasys Server and establishes a session. While this session is active this instance can be used to make additional calls to the server. Parameters: Name Type Argument Description user String The user name of the account being used to access Metasys Server pass * The password of the account being used to access Metasys Server. host * The hostname (or IP address) of the Metasys Server options Object &lt;optional&gt; Any options that you want to apply to every call as documented by request library. Source: index.js, line 177 × Search results Close "},"tutorial-example-calls.html":{"id":"tutorial-example-calls.html","title":"Tutorial: Examples Calls For Most Common Methods","body":" Metasys® Server API Modules serverkit Classes serverkit~MetasysServerApi Tutorials Examples Calls For Most Common Methods Examples Calls For Most Common Methods See the Metasys Server API for the server documentation. This will show you how to make many of the Server API calls using serverkit. AuthenticationFor all of the other examples, it is assumed that you have already imported the module and logged in as shown in the following example: const _ = require('@jci/serverkit'); const { MetasysServerApi } = _; async main() { const api = new MetasysServerApi(); await api.login('username', 'password', 'host'); } main();We choose to write our script in side of an async main method so we can take advantage of JavaScript's await/async feature which simplifies dealing with asynchronous code. Everyone of the following examples will assume that they are being written within an async method like main. Async GeneratorsThere are many methods on the Server API that return paged collections. The serverkit API provides a simplified mechanism for dealing with these paged collections. You can use the for-await syntax in ES9: const alarms = await api.alarms(); for await(const alarm in alarms) { console.log(JSON.stringify(alarm, null, 2)); }Note: Every call to an async generator method like alarms may result in calls to the server. If you want to iterate over a collection multiple times you should cache the results in a regular array: const alarms = await api.alarms(); const cachedAlarms = await _.toArray(alarms); // cachedAlarms is now a regular arrayNotice that the toArray function is also asynchronous. That is because the original generator alarms() doesn't return all the alarms at once. It fetches pages only as needed. The call to toArray forces all of the pages to be fetched and those are asynchronous operations. Hence, the need to use await on toArray. Network DevicesFind a supervisory device by itemReference. This example uses the function first provided by this library. The first function will keep fetching pages from the server until it finds the first item that matches the given predicate. It then stops searching the server. (This is more efficient than fetching all of the pages from the server if we are only looking for one item, for example.) const supervisoryDevices = await api.supervisoryDevices(); const device = await _.first(supervisoryDevices, item =&gt; item.itemReference === 'ads:nae');Building on this example we can now fetch alarms for just this network device. To do this we call the alarms api and include a value for deviceId in the query parameters we pass. const alarmsForDevices = await api.alarms({ deviceId: device.id });AlarmsFetch alarms for a given data range. const queryParameters = { startTime: '2018-01-01', endTime: '2018-02-01' }; const alarms = await api.alarms(queryParameters);Fetch a single alarm. const alarm = await api.alarm('06d68217-e4a7-48f7-a2ac-7880f328549b');Fetch alarms for a device. const alarms = await api.alarms({ deviceId: 'ac36b7c6-51b3-5236-812f-1ad6f2470947' }); × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
